---
title: "Actividad Individual I"
subtitle: "Ciencia de Datos con R"
format: html
editor: visual
---

## Introducción

El objetivo de este trabajo es aplicar herramientas de **data wrangling** con `tidyverse` y realizar **visualizaciones** utilizando `ggplot2` y `plotly`.

------------------------------------------------------------------------

## Dataset: `gapminder` (incluido en `{gapminder}`)

El dataset `gapminder` del paquete `{gapminder}` contiene datos de desarrollo mundial de los paises entre los años 1952 y 2007, con información de todos los continentes.

### Variables principales:

-   `country`: país
-   `continent`: continente
-   `year`: año de observación
-   `lifeExp`: esperanza de vida
-   `pop`: población
-   `gdpPercap`: PBI per cápita

```{r, warning=FALSE, message=FALSE, echo=FALSE}
library(tidyverse)
library(gapminder)
library(ggmosaic)
library(plotly)
library(testthat)

data(gapminder)
```

------------------------------------------------------------------------

### 1. Data Wrangling

1.1. Filtrar los países del continente asiático en el año 2007 con esperanza de vida mayor a 70 y PBI per cápita mayor a 5000; y luego calcula la mediana. Interprete el resultado. La mediana guardala en un nuevo objeto llamado `mediana`.

```{r}
#| label: ejercicio_11
mediana <- gapminder |>
  filter(
    tolower(continent) == "asia" &
      year == 2007 &
      lifeExp > 70 &
      gdpPercap > 5000
  ) |>
  pull(gdpPercap) |>
  median()

print(sprintf("La mitad de los países recolectados del continente asiático tuvieron un PBI per cápita menor a %.2f en el año 2007.", mediana))
```

1.2. Crear una nueva variable que represente el ingreso total (`gdpPercap * pop`) y visualizar la densidad del logaritmo de la variable creada. Obs: todo el proceso tiene que estar unido por pipes. Interprete la visualización obtenida. Guarde el gráfico en un objeto llamado `densidad_ingreso_total_log` y luego imprimalo.

```{r}
#| label: ejercicio_12
densidad_ingreso_total_log <- gapminder |>
  mutate(ingreso_total = gdpPercap * pop) |>
  ggplot(aes(x=log(ingreso_total))) +
  geom_density(fill="lightgrey", color="grey5") +
  geom_vline(
    aes(xintercept=mean(log(ingreso_total))), color="darkorange", size=1
  ) +
  geom_vline(
    aes(xintercept=median(log(ingreso_total))), color="skyblue", size=1
  ) +
  labs(
    title="Densidad del ingreso total (PBI per capita * poblacion)",
    subtitle=sprintf(
      "Universo: %d países del mundo\nPeríodo:%d-%d\nEscala: logaritmica",
      gapminder |> select(country) |> n_distinct(),
      min(gapminder$year),
      max(gapminder$year)
    ),
    y="Densidad",
    x="Logaritmo (en base e) del \"Ingreso total\""
  )

densidad_ingreso_total_log
# El ingreso total de los 142 paises a lo largo de la historia sigue una distribución con asimetria positiva y centrada cercanamente (pero menor) al 24 (tomando como medidas de posición central a la mediana y media).
```

1.3. Crear un nuevo data frame con las variables `country`, `year` y una variable categórica de esperanza de vida (baja \<menos de 50 años\>, media \<entre 50 y menos de 70 años\>, alta \<70 años o más\>). Luego, realizar la tabla de frecuencias de la variable categórica y la visualización de dicha tabla. La tabla de frecuencias almacenala en un objeto llamado `freq_exp_country_year` y la visualización en un objeto llamado `plot_freq_exp_country_year`

```{r}
#| label: ejercicio_13
life_exp_df <- gapminder |>
  mutate(
    esper_vida = case_when(
      lifeExp < 50 ~ "baja",
      lifeExp >= 70 ~ "alta",
      .default = "media"
    ),
    esper_vida = as_factor(esper_vida)
  ) |>
  select(country, year, esper_vida)

freq_exp_country_year <- life_exp_df |>
  count(esper_vida, sort=T, name="cant")

plot_freq_exp_country_year <- freq_exp_country_year |>
  ggplot(
    aes(x=forcats::fct_reorder(esper_vida, cant), y=cant, fill=esper_vida)
  ) +
  geom_col() +
  geom_text(aes(label = cant), hjust = -.1, colour = "black") +
  labs(
    title="Cantidad de observaciones por tipo de esperanza de vida.",
    x="Tipo de esperanza de vida",
    y="Cantidad"
  ) +
  guides(fill="none") +
  coord_flip()
plot_freq_exp_country_year
```

1.4. Usar `mutate(across())` para categorizar todas las variables numéricas en tres niveles: bajo, medio y alto. Observación: el objetivo es que cada categoria tenga aproximadamente las mismas cantidad de observaciones. El resultado debe ser un nuevo data.frame con las variables originales y las categorizadas. Guardar el nuevo data.frame en un objeto llamado `gapminder_cat`. Luego, visualizar la tabla de frecuencias de cada una de las variables categorizadas.

```{r}
#| label: ejercicio_14
gapminder_cat <- gapminder |>
  mutate(
    across(
      where(is.numeric), 
      ~ cut(
        .x, 
        breaks = quantile(., probs = c(0, 1/3, 2/3, 1), na.rm = TRUE),
        labels=c("bajo", "medio", "alto"),
        include.lowest=T
      ),
      .names="nivel_{.col}"
    )
  )

gapminder_cat |>
  pivot_longer(
    cols=starts_with("nivel_"),
    names_to="variable",
    values_to="categoria",
    names_prefix="nivel_"
  ) |>
  ggplot(
    aes(x=categoria)
  ) +
  geom_bar() +
  labs(
    title="Cantidad de observaciones por categoria de las variables numéricas.",
    subtitle="Las variables fueron divididas en 3 partes iguales (aproximadamente)",
    x="Categoria",
    y="Cantidad"
  ) +
  guides(fill="none") +
  coord_flip() +
  facet_wrap(~ variable)
```

1.5. Crear una variable `cat_pop` que clasifique los países según su población (`< 1 millón`, `1-10 millones`, `> 10 millones`). Remplaza el data.frame `gapminder_cat` por el nuevo data.frame que contiene la variable `cat_pop`.

```{r}
#| label: ejercicio_15

gapminder_cat <- gapminder_cat |>
  mutate(
    cat_pop = case_when(
      pop < 1e6 ~ "baja",
      pop > 1e7 ~ "alta",
      .default = "media"
    )
  )
gapminder_cat
```

1.6. Seleccionar las variables que contengan la letra **c**. Luego, guardar el resultado en un nuevo objeto llamado `gapminder_c`.

```{r}
#| label: ejercicio_16

gapminder_c <- gapminder |>
  select(contains("c"))
gapminder_c
```

1.7. Calcular el promedio y la desviación estándar de `lifeExp` y `gdpPercap` por continente y década. Guardar el resultado en un nuevo objeto llamado `summary_exp_continet_decade`

```{r}
#| label: ejercicio_17

summary_exp_continet_decade <- gapminder |>
  mutate(decada = round(year - year %% 10)) |>
  group_by(continent, decada) |>
  summarise(
    across(
      c("lifeExp", "gdpPercap"),
      list(media=mean, desv_std=sd),
      .names="{.fn}_{.col}"
    )
  )
summary_exp_continet_decade
```

1.8. Mostrar los 10 países con mayor esperanza de vida en 2007 usando `dplyr`. Calcula la media de la variable `gdpPercap` para dichos paises y comparala con la media global de `gdpPercap` para el año 2007. Comentar los resuktados obtenidos. El resultado con los promedios debe ser un nuevo data.frame llamado `summary_top10_exp`

```{r warning=FALSE}
#| label: ejercicio_18

summary_top10_exp <- gapminder |>
  filter(year == 2007) |>
  mutate(mean_gdpPercap_global = mean(gdpPercap)) |>
  top_n(10, lifeExp) |>
  select(country, year, lifeExp, gdpPercap, mean_gdpPercap_global) |>
  group_by(country, mean_gdpPercap_global) |>
  summarise(mean_gdpPercap = mean(gdpPercap)) |>
  arrange(desc(mean_gdpPercap))
  
summary_top10_exp
# La media del período 1952-2007 para los países del top 10 con mayor esperanza de vida es más del doble con respecto a la media de todos los países de la muestra. Los países con mayor esperanza de vida tienen un fuerte apartamiento con respecto al promedio de todos lo países.
```

1.9. Realizar un `left_join()` entre `gapminder` y el siguiente tibble. El resultado almacenalo en un nuevo objeto llamado `gapminder_join`.

```{r}
region_labels <- tibble(
  continent = c("Africa", "Americas", "Asia", "Europe","Oceania"),
  region = c("África", "Américas", "Asia", "Europa", "Oceanía"))
```

```{r}
#| label: ejercicio_19

gapminder_join <- gapminder |>
  left_join(region_labels, by="continent")
gapminder_join
```

1.10. Mover la variable `pop` al inicio del dataset. El resultado almacenalo en un nuevo objeto llamado `gapminder_pop_first`.

```{r}
#| label: ejercicio_110
gapminder_pop_first <- relocate(gapminder, pop, .before = 1)
gapminder_pop_first
```

1.11. Extraer una muestra aleatoria de aproximadamente el 10% observaciones y comparar el promedio de `lifeExp` por continente con el de la base completa. El resultado de la muestra guardalo en `sample10_gapminder` Explicar de forma "intuitiva" porque existen diferencias

```{r}
#| label: ejercicio_111
set.seed(1922)
sample10_gapminder <- gapminder |>
  slice_sample(prop=0.1) |>
  group_by(continent) |>
  summarise(mean_lifeExp = mean(lifeExp)) |>
  inner_join(
    gapminder |>
      group_by(continent) |>
      summarise(mean_base_total = mean(lifeExp)),
    by="continent"
  )
sample10_gapminder
# La media de una muestra es una estimación de la verdadera media de toda la población (que en este caso es la esperanza de vida para el período dado). Por falta de observaciones de la población total, ésta va a moverse en relación a los que quedaron en la muestra.
```

1.12. Filtrar por el año 2007, crear una variable categórica de `gdpPercap` (al igual que lo realizado en el punto 1.4), agrupar por `continent` y categoría, y calcular el promedio de `lifeExp`. Guardar el resultado en un nuevo objeto llamado `summary_gdpPercap_lifeExp`.

```{r}
#| label: ejercicio_112

summary_gdpPercap_lifeExp <- gapminder |>
  filter(year == 2007) |>
  mutate(
    cat_gdpPercap = cut(
        gdpPercap, 
        breaks = quantile(gdpPercap, probs = c(0, 1/3, 2/3, 1), na.rm = TRUE),
        labels=c("bajo", "medio", "alto"),
        include.lowest=T
    )
  ) |>
  group_by(continent, cat_gdpPercap) |>
  summarise(mean_lifeExp = mean(lifeExp))

summary_gdpPercap_lifeExp
```

1.13. Estandarizar las variables `lifeExp`, `gdpPercap` y `pop` y luego calcular sus medias y desvíos estándar. Guardar el resultado en un nuevo objeto llamado `summary_estandarizado`.

```{r}
#| label: ejercicio_113

summary_estandarizado <- gapminder |>
  mutate(across(where(is.numeric) & !c(year), scale)) |>
  summarise(across(where(is.numeric) & !c(year), list(mean=~ round(mean(.), 2), sd=sd)))

summary_estandarizado
```

1.14. Calcular el cambio en esperanza de vida entre años (utilizar la función `lag`) para cada país y agrupar según si aumentó o no. Comparar el `gdpPercap` promedio en 2007 según esa clasificación. Guardar el resultado en un nuevo objeto llamado `summary_lifeExp_gdpPercap`.

```{r}
#| label: ejercicio_114
summary_lifeExp_gdpPercap <- gapminder |>
  group_by(country) |>
  mutate(
    lifeExp_lag1 = lag(lifeExp, default=0, order_by = year),
    aumento_lifeExp = lifeExp > lifeExp_lag1
  ) |>
  group_by(year, aumento_lifeExp) |>
  summarise(mean_gdpPercap = mean(gdpPercap)) |>
  filter(year == 2007)
  
summary_lifeExp_gdpPercap
```

------------------------------------------------------------------------

## 2. Visualizaciones

Cada una de las visulizaciones debe tener: titulo, etiquetas en los ejes y todo aquello que consideres necesario para crear una buena visualización.

2.1. Gráfico de dispersión entre `gdpPercap` y `lifeExp`, coloreado por `continent`. Interpretar los resultados obtenidos.

```{r}
#| label: ejercicio_21


```

2.2. Boxplot de `lifeExp` por continente. Interpretar los resultados obtenidos

```{r}
#| label: ejercicio_22
```

2.3. Facet wrap de `gdpPercap` según año.

```{r}
#| label: ejercicio_23
```

2.4. Versión interactiva con `ggplotly()` del diagrama de dispersión realizado en el punto 2.1.

```{r}
#| label: ejercicio_24

```

2.5. Violin plot de `gdpPercap` por continente.

```{r}
#| label: ejercicio_25

```

2.6. Gráfico de mosaico de `continent` contra una categoría derivada de `lifeExp` (por ejemplo: baja, media, alta).

```{r}
#| label: ejercicio_26


```

------------------------------------------------------------------------

## Entrega

-   **La fecha limite de entrega es el 30 de abril de 2025.**

-   Las respuestas deben estar en este mismo archivo `.qmd`, el contenido deber ser completamente reproducible, es decir, cada chunk debe de funcionar sin errores para poder replicar los resultados.

-   No se aceptan archivos `.Rmd` o `.R` para la entrega. Solamente subir al repositorio el archivo `.qmd` con las respuestas.

-   Cada respuesta del ejercicio debe estar en el chunk correspondiente, no borrar la etiqueta del chunk `#| label: ejercicio_XX`.

-   Puede realizar pasos intermedios los que sean necesarios dentro del chunk pero debe de respetar el nombre del objeto final en el caso que se indique.

-   Los gráficos deben ser guardados en objetos y luego impresos en el caso que se indique que lo almacenen en un objeto. En el caso que no se indique, pueden ser impresos directamente.

-   Para comenzar la tarea deben de ir al siguiente link: [GitHub Classroom](https://classroom.github.com/a/g-XM7vb1). Una vez allí les va a pedir que indiquen su cuenta de GitHub y luego les va a crear un repositorio en su cuenta. Una vez creado el repositorio, deben de clonar el repositorio en su computadora y abrirlo con RStudio.

------------------------------------------------------------------------
